{"version":3,"sources":["Dijkstra/Edge.ts","Dijkstra/LinkedList.ts","Dijkstra/Graph.ts","Dijkstra/UndirectedGraph.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Edge","from","to","weight","this","Symbol","iterator","LinkedList","head","n","LinkedListNode","LinkedListIterator","data","next","linkedList","nextNode","currentNode","done","value","Graph","V","adjacencyList","i","edge","add","vertex","GraphIterator","graph","length","UndirectedGraph","createDOMEdges","CodeTracer","props","language","contentSetter","onChange","dijkstraCode","className","onBeforeChange","editor","options","lineWrapping","lint","mode","theme","lineNumbers","DebuggerInterface","React","useState","playing","setPlaying","step","setStep","steps","onClick","onInput","evt","currentTarget","type","min","max","GraphTracer","vertexPoints","hexagonalLattice1","relations","relationsForHexagonalLattice1","map","relation","addEdge","a","b","viewBox","style","height","width","flexGrow","border","point","createDOMVertices","d","x","y","Vertex","cx","cy","App","Component","js","setJs","display","flexDirection","alignItems","justifyContent","padding","l","Math","sqrt","vertexPositions","getNeigborhoodOf","f","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.bbbdd880.chunk.js","sourcesContent":["export class Edge {\r\n  from: number;\r\n  to: number;\r\n  weight: number;\r\n\r\n  constructor(from: number, to: number, weight: number) {\r\n    this.from = from;\r\n    this.to = to;\r\n    this.weight = weight;\r\n  }\r\n}","\r\nexport class LinkedList<T> {\r\n  head: LinkedListNode<T> | null;\r\n\r\n  constructor() {\r\n    this.head = null;\r\n  }\r\n\r\n  add(n: T) {\r\n    if (this.head == null) {\r\n      this.head = new LinkedListNode<T>(n);\r\n    } else {\r\n      this.head = new LinkedListNode<T>(n, this.head);\r\n    }\r\n  }\r\n\r\n  [Symbol.iterator](): LinkedListIterator<T> {\r\n    return new LinkedListIterator<T>(this);\r\n  }\r\n}\r\n\r\nclass LinkedListNode<T> {\r\n  data: T;\r\n  next: LinkedListNode<T> | null;\r\n  constructor(data: T, next: LinkedListNode<T> | null = null) {\r\n    this.data = data;\r\n    this.next = next;\r\n  }\r\n}\r\n\r\nclass LinkedListIterator<T> implements Iterator<T> {\r\n  nextNode: LinkedListNode<T>;\r\n  linkedList: LinkedList<T>;\r\n\r\n  constructor(linkedList: LinkedList<T>) {\r\n    this.linkedList = linkedList;\r\n    this.nextNode = linkedList.head;\r\n  }\r\n\r\n  next(): IteratorResult<T> { //TODO refactor\r\n    let currentNode: LinkedListNode<T> = this.nextNode;\r\n    if (currentNode == null) return {\r\n      done: true,\r\n      value: 0\r\n    }\r\n    this.nextNode = currentNode.next;\r\n    return {\r\n      done: currentNode == null,\r\n      value: currentNode.data,\r\n    }\r\n  }\r\n}","import { Edge } from \"./Edge\";\r\nimport { LinkedList } from \"./LinkedList\";\r\n\r\n// Graph implemented with an adjacency list\r\nexport class Graph {\r\n  V: number; // number of verticies\r\n  adjacencyList: LinkedList<Edge>[] = [];\r\n\r\n  constructor(V: number) {\r\n    this.V = V;\r\n    for (let i = 0; i < V; i++) this.adjacencyList[i] = new LinkedList();\r\n  }\r\n\r\n  addEdge(from: number, to: number, weight: number = 1) {\r\n    let edge: Edge = new Edge(from, to, weight);\r\n    this.adjacencyList[from].add(edge);\r\n  }\r\n\r\n  getNeigborhoodOf(vertex: number) {\r\n    return this.adjacencyList[vertex];\r\n  }\r\n\r\n  [Symbol.iterator](): GraphIterator {\r\n    return new GraphIterator(this);\r\n  }\r\n}\r\n\r\nclass GraphIterator implements Iterator<number> {\r\n  i: number = 0;\r\n  graph: Graph\r\n\r\n  constructor(graph: Graph) {\r\n    this.graph = graph;\r\n  }\r\n\r\n  next(): IteratorResult<number> {\r\n    let adjacencyList = this.graph.adjacencyList;\r\n    return {\r\n      done: this.i === adjacencyList.length,\r\n      value: this.i++,\r\n    }\r\n  }\r\n}\r\n\r\n","import { Graph } from \"./Graph\";\r\n\r\nexport class UndirectedGraph extends Graph {\r\n  addEdge(from: number, to: number, weight: number = 1) {\r\n    super.addEdge(from, to, weight);\r\n    super.addEdge(to, from, weight);\r\n  }\r\n}\r\n\r\n","import React, {\r\n  useRef,\r\n  useState,\r\n  useEffect,\r\n  MutableRefObject,\r\n  Component,\r\n} from \"react\"\r\nimport \"./App.css\"\r\nimport { Dijkstra } from \"./Dijkstra/Dijkstra\"\r\nimport { UndirectedGraph } from \"./Dijkstra/UndirectedGraph\"\r\nimport { Delaunay } from \"d3-delaunay\"\r\nimport * as d3 from \"d3\"\r\nimport \"codemirror/lib/codemirror.css\"\r\nimport \"codemirror/theme/material.css\"\r\nimport \"codemirror/mode/javascript/javascript\"\r\nimport { Controlled as ControlledCodeTracer } from \"react-codemirror2\"\r\n\r\nlet App = () => {\r\n  const [js, setJs] = useState(\"\")\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        display: \"flex\",\r\n        flexDirection: \"row\",\r\n        alignItems: \"stretch\",\r\n        justifyContent: \"center\",\r\n        padding: \"20px\",\r\n      }}\r\n    >\r\n      <GraphTracer></GraphTracer>\r\n      <CodeTracer\r\n        language=\"javascript\"\r\n        value={js}\r\n        contentSetter={setJs}\r\n        onChange={setJs}\r\n      ></CodeTracer>\r\n    </div>\r\n  )\r\n}\r\n\r\nlet CodeTracer = (props) => {\r\n  const { language, value, contentSetter, onChange } = props\r\n\r\n  function handleChange(editor, data, value) {\r\n    // onChange(value)\r\n  }\r\n\r\n  contentSetter(dijkstraCode)\r\n\r\n  return (\r\n    <div className=\"editor-container\">\r\n      <ControlledCodeTracer\r\n        onBeforeChange={handleChange}\r\n        value={value}\r\n        className=\"code-mirror-wrapper\"\r\n        options={{\r\n          lineWrapping: true,\r\n          lint: true,\r\n          mode: language,\r\n          theme: \"material\",\r\n          lineNumbers: true,\r\n        }}\r\n      />\r\n      <DebuggerInterface />\r\n    </div>\r\n  )\r\n}\r\n\r\nlet DebuggerInterface = () => {\r\n  const [playing, setPlaying] = React.useState(false)\r\n  const [step, setStep] = React.useState(5)\r\n  const [steps, setSteps] = React.useState(10)\r\n\r\n  let handleInputChange = (evt) => {\r\n    setStep(evt.currentTarget.value)\r\n  }\r\n\r\n  let handlePlay = () => {\r\n    setPlaying(!playing)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"debugger-interface\">\r\n        <button onClick={handlePlay} className=\"debugger-button\">\r\n          {playing ? \"pause\" : \"play\"}\r\n        </button>\r\n        <input\r\n          className=\"debugger-scrubber\"\r\n          onInput={handleInputChange}\r\n          type=\"range\"\r\n          value={step}\r\n          min=\"1\"\r\n          max={steps}\r\n        />\r\n        <button className=\"debugger-button\">\r\n          Step {step} / {steps}\r\n        </button>\r\n      </div>\r\n      <div className=\"debugger-interface\">\r\n        <button className=\"debugger-button\">step-over</button>\r\n        <button className=\"debugger-button\">step-into</button>\r\n        <button className=\"debugger-button\">step-out</button>\r\n      </div>\r\n    </>\r\n  )\r\n}\r\n\r\nlet GraphTracer = () => {\r\n  let vertexPoints = hexagonalLattice1\r\n  let relations = relationsForHexagonalLattice1\r\n\r\n  let graph = new UndirectedGraph(vertexPoints.length)\r\n  relations.map((relation) => graph.addEdge(relation.a, relation.b))\r\n\r\n  return (\r\n    <svg\r\n      viewBox=\"-100 -100 200 200\"\r\n      style={{\r\n        height: \"100%\",\r\n        width: \"100%\",\r\n        flexGrow: 1,\r\n        border: \"1px solid white\",\r\n      }}\r\n    >\r\n      {[...createDOMEdges(graph, vertexPoints)]}\r\n      {[...createDOMVertices(vertexPoints)]}\r\n    </svg>\r\n  )\r\n}\r\n\r\nlet Edge = (props) => {\r\n  return (\r\n    <path\r\n      className=\"edge\"\r\n      d={`M${props.from.x},${props.from.y} L ${props.to.x},${props.to.y}`}\r\n    />\r\n  )\r\n}\r\n\r\nlet Vertex = (props) => {\r\n  return <circle className=\"vertex\" cx={props.point.x} cy={props.point.y} />\r\n}\r\n\r\nclass GraphTracerDelaunayVoronoi extends Component {\r\n  myRef: React.RefObject<any>\r\n\r\n  constructor(props) {\r\n    super(props)\r\n    this.myRef = React.createRef()\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <canvas ref={this.myRef} width=\"1000\" height=\"1000\"></canvas>\r\n      </>\r\n    )\r\n  }\r\n\r\n  componentDidMount() {\r\n    const points = []\r\n    // for (let i = 0; i < 100; i++) {\r\n    //   points.push([\r\n    //     Math.floor(Math.random() * 1000),\r\n    //     Math.floor(Math.random() * 1000),\r\n    //   ])\r\n    // }\r\n\r\n    for (let i = 0; i < 1000; i += 100) {\r\n      for (let j = 0; j < 1000; j += 100) {\r\n        points.push([i, j])\r\n      }\r\n    }\r\n\r\n    const delaunay = Delaunay.from(points)\r\n    const voronoi = delaunay.voronoi([0, 0, 1000, 1000])\r\n\r\n    const context = this.myRef.current.getContext(\"2d\")\r\n\r\n    // Voronoi diagram\r\n    // == Points ==\r\n    context.beginPath()\r\n    delaunay.renderPoints(context)\r\n    context.fillStyle = \"white\"\r\n    context.fill()\r\n\r\n    // == Border ==\r\n    context.beginPath()\r\n    voronoi.render(context)\r\n    context.strokeStyle = \"grey\"\r\n    context.stroke()\r\n\r\n    // Delaunay triangulation (graph)\r\n    context.globalCompositeOperation = \"darken\"\r\n    context.beginPath()\r\n    delaunay.renderPoints(context)\r\n    context.fillStyle = \"grey\"\r\n    context.fill()\r\n    context.strokeStyle = \"white\"\r\n    for (let i = 0, n = delaunay.triangles.length / 3; i < n; ++i) {\r\n      context.beginPath()\r\n      delaunay.renderTriangle(i, context)\r\n      context.stroke()\r\n    }\r\n\r\n    return context.canvas\r\n  }\r\n}\r\n\r\nexport default App\r\n\r\nlet l = 50\r\nconst hexagonalLattice1 = [\r\n  { x: -1 * l, y: 0 },\r\n  { x: 0 * l, y: 0 },\r\n  { x: 1 * l, y: 0 },\r\n  { x: -l / 2, y: (l / 2) * Math.sqrt(3) },\r\n  { x: -l / 2, y: (-l / 2) * Math.sqrt(3) },\r\n  { x: l / 2, y: (l / 2) * Math.sqrt(3) },\r\n  { x: l / 2, y: (-l / 2) * Math.sqrt(3) },\r\n]\r\n\r\nconst relationsForHexagonalLattice1 = [\r\n  { a: 1, b: 0 },\r\n  { a: 1, b: 2 },\r\n  { a: 1, b: 3 },\r\n  { a: 1, b: 4 },\r\n  { a: 1, b: 5 },\r\n  { a: 1, b: 6 },\r\n  { a: 0, b: 4 },\r\n  { a: 4, b: 6 },\r\n  { a: 6, b: 2 },\r\n  { a: 0, b: 3 },\r\n  { a: 3, b: 5 },\r\n  { a: 5, b: 2 },\r\n]\r\n\r\nconst squareLattice3x3 = [\r\n  { x: -50, y: -50 },\r\n  { x: 0, y: -50 },\r\n  { x: 50, y: -50 },\r\n  { x: -50, y: 0 },\r\n  { x: 0, y: 0 },\r\n  { x: 50, y: 0 },\r\n  { x: -50, y: 50 },\r\n  { x: 0, y: 50 },\r\n  { x: 50, y: 50 },\r\n]\r\n\r\nconst relationsForSquareLattice3x3 = [\r\n  { a: 0, b: 1 },\r\n  { a: 1, b: 2 },\r\n  { a: 0, b: 3 },\r\n  { a: 1, b: 4 },\r\n  { a: 2, b: 5 },\r\n  { a: 3, b: 4 },\r\n  { a: 4, b: 5 },\r\n  { a: 3, b: 6 },\r\n  { a: 4, b: 7 },\r\n  { a: 5, b: 8 },\r\n  { a: 6, b: 7 },\r\n  { a: 7, b: 8 },\r\n]\r\n\r\nfunction createDOMVertices(vertexPoints: { x: number; y: number }[]) {\r\n  return vertexPoints.map((point) => <Vertex point={point}></Vertex>)\r\n}\r\n\r\nfunction* createDOMEdges(\r\n  graph: UndirectedGraph,\r\n  vertexPositions: { x: number; y: number }[]\r\n) {\r\n  for (let i = 0; i < vertexPositions.length; i++) {\r\n    for (const edge of graph.getNeigborhoodOf(i)) {\r\n      let from = vertexPositions[edge.from]\r\n      let to = vertexPositions[edge.to]\r\n      yield (<Edge from={from} to={to} />)\r\n    }\r\n  }\r\n}\r\n\r\nlet dijkstraCode = `export class Dijkstra {\r\n  distTo: number[];\r\n  edgeTo: Edge[];\r\n  pq: MinPQ;\r\n\r\n  constructor(graph: Graph, startVertex: number) {\r\n    this.edgeTo = new Array<Edge>(graph.V);\r\n    this.distTo = new Array<number>(graph.V);\r\n    this.pq = new MinPQ(graph.V);\r\n\r\n    for (let v = 0; v < graph.V; v++) this.distTo[v] = Infinity;\r\n    this.distTo[startVertex] = 0;\r\n\r\n    this.pq.insert(startVertex, 0);\r\n    while (!this.pq.isEmpty()) {\r\n      this.relax(graph, this.pq.popMin());\r\n    };\r\n\r\n  }\r\n\r\n  relax(graph: Graph, fromVertex: number) {\r\n    for (const edge of graph.getNeigborhoodOf(fromVertex)) {\r\n      let toVertex: number = edge.to;\r\n      if (this.distTo[toVertex] > this.distTo[fromVertex] + edge.weight) {\r\n        this.distTo[toVertex] = this.distTo[fromVertex] + edge.weight;\r\n        this.edgeTo[toVertex] = edge;\r\n        if (this.pq.contains(toVertex)) this.pq.changeKey(toVertex, this.distTo[toVertex]);\r\n        else this.pq.insert(toVertex, this.distTo[toVertex]);\r\n      }\r\n    }\r\n  }\r\n\r\n  getDistTo(vertex: number): number {\r\n    return this.distTo[vertex];\r\n  }\r\n\r\n  hasPathTo(vertex: number) {\r\n    return this.distTo[vertex] < Infinity;\r\n  }\r\n\r\n  getPathTo(vertex: number): Array<Edge> {\r\n    if (!this.hasPathTo(vertex)) return null;\r\n    let path = new Array<Edge>();\r\n    for (let edge = this.edgeTo[vertex]; edge != null; edge = this.edgeTo[edge.from]) {\r\n      path.push(edge);\r\n    }\r\n    return path;\r\n  }\r\n}`\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"./index.css\"\nimport App from \"./App\"\nimport * as serviceWorker from \"./serviceWorker\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}